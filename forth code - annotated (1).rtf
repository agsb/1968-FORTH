{\rtf1\ansi\deff0\ansicpg1252 {\*\tmtxbx }{\fonttbl{\f0\froman\fcharset0 Times New Roman;}{\f1\froman\fcharset177 Times New Roman (Hebrew);}{\f2\froman\fcharset178 Times New Roman (Arabic);}{\f3\froman\fcharset161 Times New Roman Greek;
}{\f4\froman\fcharset162 Times New Roman TUR;}{\f5\froman\fcharset186 Times New Roman Baltic;}{\f6\froman\fcharset238 Times New Roman CE;}{\f7\froman\fcharset204 Times New Roman CYR;}{\f8\froman\fcharset163 Times New Roman (Vietnamese);
}{\f9\froman\fcharset0 SimSun;}{\f10\froman\fcharset0 Arial;}{\f11\froman\fcharset177 Arial (Hebrew);}{\f12\froman\fcharset178 Arial (Arabic);}{\f13\froman\fcharset161 Arial Greek;}{\f14\froman\fcharset162 Arial TUR;}{\f15\froman
\fcharset186 Arial Baltic;}{\f16\froman\fcharset238 Arial CE;}{\f17\froman\fcharset204 Arial CYR;}{\f18\froman\fcharset163 Arial (Vietnamese);}{\f19\froman\fcharset0 Times New Roman Greek;}{\f20\froman\fcharset177 Times New Roman Greek (Hebrew);
}{\f21\froman\fcharset178 Times New Roman Greek (Arabic);}{\f22\froman\fcharset161 Times New Roman Greek Greek;}{\f23\froman\fcharset162 Times New Roman Greek TUR;}{\f24\froman\fcharset186 Times New Roman Greek Baltic;}{\f25
\froman\fcharset238 Times New Roman Greek CE;}{\f26\froman\fcharset204 Times New Roman Greek CYR;}{\f27\froman\fcharset163 Times New Roman Greek (Vietnamese);}{\f28\froman\fcharset0 Times New Roman TUR;}{\f29\froman\fcharset177
Times New Roman TUR (Hebrew);}{\f30\froman\fcharset178 Times New Roman TUR (Arabic);}{\f31\froman\fcharset161 Times New Roman TUR Greek;}{\f32\froman\fcharset162 Times New Roman TUR TUR;}{\f33\froman\fcharset186 Times New Roman TUR Baltic;
}{\f34\froman\fcharset238 Times New Roman TUR CE;}{\f35\froman\fcharset204 Times New Roman TUR CYR;}{\f36\froman\fcharset163 Times New Roman TUR (Vietnamese);}{\f37\froman\fcharset0 Times New Roman Baltic;}{\f38\froman\fcharset177
Times New Roman Baltic (Hebrew);}{\f39\froman\fcharset178 Times New Roman Baltic (Arabic);}{\f40\froman\fcharset161 Times New Roman Baltic Greek;}{\f41\froman\fcharset162 Times New Roman Baltic TUR;}{\f42\froman\fcharset186
Times New Roman Baltic Baltic;}{\f43\froman\fcharset238 Times New Roman Baltic CE;}{\f44\froman\fcharset204 Times New Roman Baltic CYR;}{\f45\froman\fcharset163 Times New Roman Baltic (Vietnamese);}{\f46\froman\fcharset0 Times New Roman CE;
}{\f47\froman\fcharset177 Times New Roman CE (Hebrew);}{\f48\froman\fcharset178 Times New Roman CE (Arabic);}{\f49\froman\fcharset161 Times New Roman CE Greek;}{\f50\froman\fcharset162 Times New Roman CE TUR;}{\f51\froman
\fcharset186 Times New Roman CE Baltic;}{\f52\froman\fcharset238 Times New Roman CE CE;}{\f53\froman\fcharset204 Times New Roman CE CYR;}{\f54\froman\fcharset163 Times New Roman CE (Vietnamese);}{\f55\froman\fcharset0 Times New Roman CYR;
}{\f56\froman\fcharset177 Times New Roman CYR (Hebrew);}{\f57\froman\fcharset178 Times New Roman CYR (Arabic);}{\f58\froman\fcharset161 Times New Roman CYR Greek;}{\f59\froman\fcharset162 Times New Roman CYR TUR;}{\f60\froman
\fcharset186 Times New Roman CYR Baltic;}{\f61\froman\fcharset238 Times New Roman CYR CE;}{\f62\froman\fcharset204 Times New Roman CYR CYR;}{\f63\froman\fcharset163 Times New Roman CYR (Vietnamese);}{\f64\froman\fcharset0
Arial Greek;}{\f65\froman\fcharset177 Arial Greek (Hebrew);}{\f66\froman\fcharset178 Arial Greek (Arabic);}{\f67\froman\fcharset161 Arial Greek Greek;}{\f68\froman\fcharset162 Arial Greek TUR;}{\f69\froman\fcharset186 Arial Greek Baltic;
}{\f70\froman\fcharset238 Arial Greek CE;}{\f71\froman\fcharset204 Arial Greek CYR;}{\f72\froman\fcharset163 Arial Greek (Vietnamese);}{\f73\froman\fcharset0 Arial TUR;}{\f74\froman\fcharset177 Arial TUR (Hebrew);}{\f75\froman
\fcharset178 Arial TUR (Arabic);}{\f76\froman\fcharset161 Arial TUR Greek;}{\f77\froman\fcharset162 Arial TUR TUR;}{\f78\froman\fcharset186 Arial TUR Baltic;}{\f79\froman\fcharset238 Arial TUR CE;}{\f80\froman\fcharset204
Arial TUR CYR;}{\f81\froman\fcharset163 Arial TUR (Vietnamese);}{\f82\froman\fcharset0 Arial Baltic;}{\f83\froman\fcharset177 Arial Baltic (Hebrew);}{\f84\froman\fcharset178 Arial Baltic (Arabic);}{\f85\froman\fcharset161
Arial Baltic Greek;}{\f86\froman\fcharset162 Arial Baltic TUR;}{\f87\froman\fcharset186 Arial Baltic Baltic;}{\f88\froman\fcharset238 Arial Baltic CE;}{\f89\froman\fcharset204 Arial Baltic CYR;}{\f90\froman\fcharset163 Arial Baltic (Vietnamese);
}{\f91\froman\fcharset0 Arial CE;}{\f92\froman\fcharset177 Arial CE (Hebrew);}{\f93\froman\fcharset178 Arial CE (Arabic);}{\f94\froman\fcharset161 Arial CE Greek;}{\f95\froman\fcharset162 Arial CE TUR;}{\f96\froman\fcharset186
Arial CE Baltic;}{\f97\froman\fcharset238 Arial CE CE;}{\f98\froman\fcharset204 Arial CE CYR;}{\f99\froman\fcharset163 Arial CE (Vietnamese);}{\f100\froman\fcharset0 Arial CYR;}{\f101\froman\fcharset177 Arial CYR (Hebrew);
}{\f102\froman\fcharset178 Arial CYR (Arabic);}{\f103\froman\fcharset161 Arial CYR Greek;}{\f104\froman\fcharset162 Arial CYR TUR;}{\f105\froman\fcharset186 Arial CYR Baltic;}{\f106\froman\fcharset238 Arial CYR CE;}{\f107\froman
\fcharset204 Arial CYR CYR;}{\f108\froman\fcharset163 Arial CYR (Vietnamese);}{\f109\fnil\fcharset177 Times New Roman Greek (Hebrew);}{\f110\fnil\fcharset178 Times New Roman Greek (Arabic);}{\f111\fnil\fcharset161 Times New Roman Greek Greek;
}{\f112\fnil\fcharset162 Times New Roman Greek TUR;}{\f113\fnil\fcharset186 Times New Roman Greek Baltic;}{\f114\fnil\fcharset238 Times New Roman Greek CE;}{\f115\fnil\fcharset204 Times New Roman Greek CYR;}{\f116\fnil\fcharset163
Times New Roman Greek (Vietnamese);}{\f117\fnil\fcharset177 Times New Roman TUR (Hebrew);}{\f118\fnil\fcharset178 Times New Roman TUR (Arabic);}{\f119\fnil\fcharset161 Times New Roman TUR Greek;}{\f120\fnil\fcharset162 Times New Roman TUR TUR;
}{\f121\fnil\fcharset186 Times New Roman TUR Baltic;}{\f122\fnil\fcharset238 Times New Roman TUR CE;}{\f123\fnil\fcharset204 Times New Roman TUR CYR;}{\f124\fnil\fcharset163 Times New Roman TUR (Vietnamese);}{\f125\fnil\fcharset177
Times New Roman Baltic (Hebrew);}{\f126\fnil\fcharset178 Times New Roman Baltic (Arabic);}{\f127\fnil\fcharset161 Times New Roman Baltic Greek;}{\f128\fnil\fcharset162 Times New Roman Baltic TUR;}{\f129\fnil\fcharset186 Times New Roman Baltic Baltic;
}{\f130\fnil\fcharset238 Times New Roman Baltic CE;}{\f131\fnil\fcharset204 Times New Roman Baltic CYR;}{\f132\fnil\fcharset163 Times New Roman Baltic (Vietnamese);}{\f133\fnil\fcharset177 Times New Roman CE (Hebrew);}{\f134
\fnil\fcharset178 Times New Roman CE (Arabic);}{\f135\fnil\fcharset161 Times New Roman CE Greek;}{\f136\fnil\fcharset162 Times New Roman CE TUR;}{\f137\fnil\fcharset186 Times New Roman CE Baltic;}{\f138\fnil\fcharset238 Times New Roman CE CE;
}{\f139\fnil\fcharset204 Times New Roman CE CYR;}{\f140\fnil\fcharset163 Times New Roman CE (Vietnamese);}{\f141\fnil\fcharset177 Times New Roman CYR (Hebrew);}{\f142\fnil\fcharset178 Times New Roman CYR (Arabic);}{\f143\fnil
\fcharset161 Times New Roman CYR Greek;}{\f144\fnil\fcharset162 Times New Roman CYR TUR;}{\f145\fnil\fcharset186 Times New Roman CYR Baltic;}{\f146\fnil\fcharset238 Times New Roman CYR CE;}{\f147\fnil\fcharset204 Times New Roman CYR CYR;
}{\f148\fnil\fcharset163 Times New Roman CYR (Vietnamese);}{\f149\fnil\fcharset177 Arial Greek (Hebrew);}{\f150\fnil\fcharset178 Arial Greek (Arabic);}{\f151\fnil\fcharset161 Arial Greek Greek;}{\f152\fnil\fcharset162 Arial Greek TUR;
}{\f153\fnil\fcharset186 Arial Greek Baltic;}{\f154\fnil\fcharset238 Arial Greek CE;}{\f155\fnil\fcharset204 Arial Greek CYR;}{\f156\fnil\fcharset163 Arial Greek (Vietnamese);}{\f157\fnil\fcharset177 Arial TUR (Hebrew);}{\f158
\fnil\fcharset178 Arial TUR (Arabic);}{\f159\fnil\fcharset161 Arial TUR Greek;}{\f160\fnil\fcharset162 Arial TUR TUR;}{\f161\fnil\fcharset186 Arial TUR Baltic;}{\f162\fnil\fcharset238 Arial TUR CE;}{\f163\fnil\fcharset204
Arial TUR CYR;}{\f164\fnil\fcharset163 Arial TUR (Vietnamese);}{\f165\fnil\fcharset177 Arial Baltic (Hebrew);}{\f166\fnil\fcharset178 Arial Baltic (Arabic);}{\f167\fnil\fcharset161 Arial Baltic Greek;}{\f168\fnil\fcharset162
Arial Baltic TUR;}{\f169\fnil\fcharset186 Arial Baltic Baltic;}{\f170\fnil\fcharset238 Arial Baltic CE;}{\f171\fnil\fcharset204 Arial Baltic CYR;}{\f172\fnil\fcharset163 Arial Baltic (Vietnamese);}{\f173\fnil\fcharset177 Arial CE (Hebrew);
}{\f174\fnil\fcharset178 Arial CE (Arabic);}{\f175\fnil\fcharset161 Arial CE Greek;}{\f176\fnil\fcharset162 Arial CE TUR;}{\f177\fnil\fcharset186 Arial CE Baltic;}{\f178\fnil\fcharset238 Arial CE CE;}{\f179\fnil\fcharset204
Arial CE CYR;}{\f180\fnil\fcharset163 Arial CE (Vietnamese);}{\f181\fnil\fcharset177 Arial CYR (Hebrew);}{\f182\fnil\fcharset178 Arial CYR (Arabic);}{\f183\fnil\fcharset161 Arial CYR Greek;}{\f184\fnil\fcharset162 Arial CYR TUR;
}{\f185\fnil\fcharset186 Arial CYR Baltic;}{\f186\fnil\fcharset238 Arial CYR CE;}{\f187\fnil\fcharset204 Arial CYR CYR;}{\f188\fnil\fcharset163 Arial CYR (Vietnamese);}{\f189\froman\fcharset0 Courier New;}{\f190\froman\fcharset177
Courier New (Hebrew);}{\f191\froman\fcharset178 Courier New (Arabic);}{\f192\froman\fcharset161 Courier New Greek;}{\f193\froman\fcharset162 Courier New TUR;}{\f194\froman\fcharset186 Courier New Baltic;}{\f195\froman\fcharset238
Courier New CE;}{\f196\froman\fcharset204 Courier New CYR;}{\f197\froman\fcharset163 Courier New (Vietnamese);}{\f198\froman\fcharset0 Courier New Greek;}{\f199\froman\fcharset177 Courier New Greek (Hebrew);}{\f200\froman
\fcharset178 Courier New Greek (Arabic);}{\f201\froman\fcharset161 Courier New Greek Greek;}{\f202\froman\fcharset162 Courier New Greek TUR;}{\f203\froman\fcharset186 Courier New Greek Baltic;}{\f204\froman\fcharset238 Courier New Greek CE;
}{\f205\froman\fcharset204 Courier New Greek CYR;}{\f206\froman\fcharset163 Courier New Greek (Vietnamese);}{\f207\froman\fcharset0 Courier New TUR;}{\f208\froman\fcharset177 Courier New TUR (Hebrew);}{\f209\froman\fcharset178
Courier New TUR (Arabic);}{\f210\froman\fcharset161 Courier New TUR Greek;}{\f211\froman\fcharset162 Courier New TUR TUR;}{\f212\froman\fcharset186 Courier New TUR Baltic;}{\f213\froman\fcharset238 Courier New TUR CE;}{\f214
\froman\fcharset204 Courier New TUR CYR;}{\f215\froman\fcharset163 Courier New TUR (Vietnamese);}{\f216\froman\fcharset0 Courier New Baltic;}{\f217\froman\fcharset177 Courier New Baltic (Hebrew);}{\f218\froman\fcharset178
Courier New Baltic (Arabic);}{\f219\froman\fcharset161 Courier New Baltic Greek;}{\f220\froman\fcharset162 Courier New Baltic TUR;}{\f221\froman\fcharset186 Courier New Baltic Baltic;}{\f222\froman\fcharset238 Courier New Baltic CE;
}{\f223\froman\fcharset204 Courier New Baltic CYR;}{\f224\froman\fcharset163 Courier New Baltic (Vietnamese);}{\f225\froman\fcharset0 Courier New CE;}{\f226\froman\fcharset177 Courier New CE (Hebrew);}{\f227\froman\fcharset178
Courier New CE (Arabic);}{\f228\froman\fcharset161 Courier New CE Greek;}{\f229\froman\fcharset162 Courier New CE TUR;}{\f230\froman\fcharset186 Courier New CE Baltic;}{\f231\froman\fcharset238 Courier New CE CE;}{\f232\froman
\fcharset204 Courier New CE CYR;}{\f233\froman\fcharset163 Courier New CE (Vietnamese);}{\f234\froman\fcharset0 Courier New CYR;}{\f235\froman\fcharset177 Courier New CYR (Hebrew);}{\f236\froman\fcharset178 Courier New CYR (Arabic);
}{\f237\froman\fcharset161 Courier New CYR Greek;}{\f238\froman\fcharset162 Courier New CYR TUR;}{\f239\froman\fcharset186 Courier New CYR Baltic;}{\f240\froman\fcharset238 Courier New CYR CE;}{\f241\froman\fcharset204 Courier New CYR CYR;
}{\f242\froman\fcharset163 Courier New CYR (Vietnamese);}{\f243\fnil\fcharset177 Courier New Greek (Hebrew);}{\f244\fnil\fcharset178 Courier New Greek (Arabic);}{\f245\fnil\fcharset161 Courier New Greek Greek;}{\f246\fnil
\fcharset162 Courier New Greek TUR;}{\f247\fnil\fcharset186 Courier New Greek Baltic;}{\f248\fnil\fcharset238 Courier New Greek CE;}{\f249\fnil\fcharset204 Courier New Greek CYR;}{\f250\fnil\fcharset163 Courier New Greek (Vietnamese);
}{\f251\fnil\fcharset177 Courier New TUR (Hebrew);}{\f252\fnil\fcharset178 Courier New TUR (Arabic);}{\f253\fnil\fcharset161 Courier New TUR Greek;}{\f254\fnil\fcharset162 Courier New TUR TUR;}{\f255\fnil\fcharset186 Courier New TUR Baltic;
}{\f256\fnil\fcharset238 Courier New TUR CE;}{\f257\fnil\fcharset204 Courier New TUR CYR;}{\f258\fnil\fcharset163 Courier New TUR (Vietnamese);}{\f259\fnil\fcharset177 Courier New Baltic (Hebrew);}{\f260\fnil\fcharset178 Courier New Baltic (Arabic);
}{\f261\fnil\fcharset161 Courier New Baltic Greek;}{\f262\fnil\fcharset162 Courier New Baltic TUR;}{\f263\fnil\fcharset186 Courier New Baltic Baltic;}{\f264\fnil\fcharset238 Courier New Baltic CE;}{\f265\fnil\fcharset204 Courier New Baltic CYR;
}{\f266\fnil\fcharset163 Courier New Baltic (Vietnamese);}{\f267\fnil\fcharset177 Courier New CE (Hebrew);}{\f268\fnil\fcharset178 Courier New CE (Arabic);}{\f269\fnil\fcharset161 Courier New CE Greek;}{\f270\fnil\fcharset162
Courier New CE TUR;}{\f271\fnil\fcharset186 Courier New CE Baltic;}{\f272\fnil\fcharset238 Courier New CE CE;}{\f273\fnil\fcharset204 Courier New CE CYR;}{\f274\fnil\fcharset163 Courier New CE (Vietnamese);}{\f275\fnil\fcharset177
Courier New CYR (Hebrew);}{\f276\fnil\fcharset178 Courier New CYR (Arabic);}{\f277\fnil\fcharset161 Courier New CYR Greek;}{\f278\fnil\fcharset162 Courier New CYR TUR;}{\f279\fnil\fcharset186 Courier New CYR Baltic;}{\f280\fnil
\fcharset238 Courier New CYR CE;}{\f281\fnil\fcharset204 Courier New CYR CYR;}{\f282\fnil\fcharset163 Courier New CYR (Vietnamese);}{\f283\froman\fcharset2 Wingdings;}{\f284\froman\fcharset2 Symbol;}}{\colortbl;\red0\green0
\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue127;\red0\green127\blue127;
\red0\green127\blue0;\red127\green0\blue127;\red127\green0\blue0;\red127\green127\blue0;\red127\green127\blue127;\red192\green192\blue192;\red230\green230\blue230;\red204\green204\blue204;\red179\green179\blue179;
\red153\green153\blue153;\red127\green127\blue127;\red102\green102\blue102;\red77\green77\blue77;\red51\green51\blue51;}{\stylesheet {\s1\ltrpar\ql\li0\ri0\fi0\level0\sb0\sa0\sbauto0\saauto0\nowidctlpar\sl0\hyphpar1\rtlch
\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\fs20\cf0\up0\charscalex100\expndtw0\b0\scaps0\ulnone\i0\kerning1\strike0\v0\caps0\lang1033\chcbpat0\highlight0\snext1 Normal;}{\s2\ltrpar
\ql\li0\ri0\fi0\level1\sb240\sa60\sbauto0\saauto0\nowidctlpar\sl0\keepn\hyphpar1\keep\rtlch\af10\afs36\alang1033\ltrch\dbch\af9\afs36\alang1033\ab\hich\af10\afs36\alang1033\ab\loch\f10\fs36\cf0\up0\charscalex100\expndtw0\b1
\scaps0\ulnone\i0\kerning1\strike0\v0\caps0\lang1033\chcbpat0\highlight0\sbasedon1\snext1 Heading 1;}{\s3\ltrpar\ql\li0\ri0\fi0\level2\sb240\sa60\sbauto0\saauto0\nowidctlpar\sl0\keepn\hyphpar1\keep\rtlch\af10\afs32\alang1033\ltrch
\dbch\af9\afs32\alang1033\ab\hich\af10\afs32\alang1033\ab\loch\f10\fs32\cf0\up0\charscalex100\expndtw0\b1\scaps0\ulnone\i0\kerning1\strike0\v0\caps0\lang1033\chcbpat0\highlight0\sbasedon2\snext1 Heading 2;}{\s4\ltrpar\ql\li0
\ri0\fi0\level3\sb240\sa60\sbauto0\saauto0\nowidctlpar\sl0\keepn\hyphpar1\keep\rtlch\af10\afs28\alang1033\ltrch\dbch\af9\afs28\alang1033\ab\hich\af10\afs28\alang1033\ab\loch\f10\fs28\cf0\up0\charscalex100\expndtw0\b1\scaps0
\ulnone\i0\kerning1\strike0\v0\caps0\lang1033\chcbpat0\highlight0\sbasedon3\snext1 Heading 3;}{\s5\ltrpar\ql\li0\ri0\fi0\level0\sb0\sa0\sbauto0\saauto0\nowidctlpar\sl0\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20
\alang1033\hich\af189\afs20\alang1033\loch\f189\fs20\cf0\up0\charscalex100\expndtw0\b0\scaps0\ulnone\i0\kerning1\strike0\v0\caps0\lang1033\chcbpat0\highlight0\sbasedon1\snext5 Plain Text;}{\*\cs6\rtlch\af0\afs24\alang1033\ltrch
\dbch\af0\afs24\alang1033\hich\af0\afs20\alang1033\loch\f0\fs20\cf0\up0\charscalex100\expndtw0\b0\scaps0\ulnone\i0\kerning1\strike0\v0\caps0\lang1033\chcbpat0 Normal;}}{\*\revtbl {Unknown;}}{\info {\title }{\subject }{\author
}{\keywords }{\doccomm }{\operator Carl Claunch}{\creatim\yr2018\mo3\dy15\hr15\min37\sec32 }{\revtim\yr2018\mo4\dy1\hr22\min6\sec36 }}\deflang1033\widowctrl\hyphauto\paperw15841\paperh12241\margl1440\margr1440\margt1440\margb1440
\sectd\sbknone\guttersxn0\vertalt\lndscpsxn\ltrpar\pard\ltrpar\s5\ql\li0\ri0\fi0\level0\sb0\sa0\sbauto0\saauto0\nowidctlpar\sl0\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch
\f189\fs20\cf0\up0\charscalex100\expndtw0\b0\scaps0\ulnone\i0\kerning1\strike0\v0\caps0\lang1033\chcbpat0\highlight0\par
\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch --------------------------------------------------------------------------------\par
these are the primitives in the assembler program\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\par
\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch --------------------------------------------------------------------------------\par
\par
primitives used by FORTH code\par
\par
E - will put the next location in dictionary variable section (+4 from E1) on stack\par
\par
E1 - will put the highest valid entry in dictionary variable section onto the stack\par
\par
IC - will push the current instruction counter (of forth instructions) onto stack\par
\par
LIT - will put the literal value onto the stack\par
\par
OR - will OR together the top two values on stack and replace with single result\par
\par
LOC - will fetch next name in stream and look it up in the dictionary\par
      pushing the execution address of that item onto the stack \par
\tab this is the \u8217\'92 verb to look up a word in the dictionary \par
\par
NEXT - will find next word, interpret it and execute\par
\par
INC - will bump up the value of a variable by 1 - variable address on top of stack\par
      and will also place that value on the stack in place of variable address\par
\par
HEX - sets space on variable part of dictionary for a hex variable\par
\par
; or , or END - finishes a definition and switches back to execute mode\par
: or . - switches into definition mode, storing the remaining text up to \par
\tab the ; in the variable entry for this word, and causing it to be \par
\tab interpreted whenever it is used\par
\par
\'a2 or OPERATION - generates 1130 machine language as a callable routine\par
\tab to be executed when this word is used\par
\tab more modern versions used CODE instead\par
\par
=    - store a value into an address in core  (n1 n2 -- ) put value n1 into location n2\par
\par
ENTRY - makes a dictionary entry - grabbing the next word from the input stream\par
\tab and establishing an entry in the fixed part of the dictionary\par
\par
INTEGER - sets space on variable part of dictionary for an integer variable, \par
\tab putting the variable name in the fixed dictionary and when it is used\par
\tab the code executed will put its address from variable part onto the stack\par
\par
CONVERT - switches packed EBCDIC words to packed FORTH code words\par
\tab uses a 64 word table that is organized by FORTH code values\par
\tab and the entries in that table are EBCDIC codes\par
\par
DEPOSIT - put next char in work area - OVERRIDDEN BY FORTH DISK FILE\par
\tab so that DEPOSIT\par
\par
FETCH - get next character from startup disk buffer, typewriter buffer or \par
\tab the user disk buffer\par
\par
\par
primitives not found in the bootup FORTH code\par
FIND - look up an entry in the dictionary \par
RECURSE - Push down return address and start execution\par
FORT - will start basic FORTH loop getting words, interpreting and executing\par
PUT - will put a character from stack into print line\par
PRINT - will print the current print line\par
ADDRESS - store an address (e.g. to a variable or code pointer (IC)\par
\tab this is called by E, E1 and IC which are called by FORTH code\par
SD - Replaces top of stack value with the current code pointer (IC)\par
\par
--------------------------------------------------------------------------------\par
Important synonyms used for more widely recognized forth characters\par
--------------------------------------------------------------------------------\par
\par
The actual file written by Chuck Moore used:\par
\tab . as a synonym for :\par
\tab , as a synonym for ;\par
OPERATION as a synonym for \'a2(cent-sign) or CODE\par
\par
\rtlch\af189\afs20\alang1033\ab\ltrch\dbch\af189\afs20\alang1033\ab\hich\af189\afs20\alang1033\ab\loch\b1 In charts below,\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\b0  \tab
\rtlch\af189\afs20\alang1033\ab\ltrch\dbch\af189\afs20\alang1033\ab\hich\af189\afs20\alang1033\ab\loch\b1 (a b -- c) is change in stack,    var: is addition to variable dictionary entry\par
\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\b0     \tab\tab\tab\tab gen: is what it will generate when compiled\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033 --------------------------------------------------------------------------------\par
THE SECTION BELOW COVERS METHOD OF STORING INSTRUCTIONS AND MANAGING THE FORTH PROGRAM COUNTER (IC)\par
--------------------------------------------------------------------------------\par
:DEP  LOC DEPOSIT;         \tab ( -- execaddr(DEPOSIT)) var: ()   same as \u8217\'92 DEPOSIT in modern FORTH\par
\tab\tab\tab\tab\tab find the execution address of DEPOSIT (builtin) and put on stack\par
\par
:DEPOSIT  IC INC=;         \tab (n -- )  gen: (n)    and bumps IC by 1\par
\tab\tab\tab\tab\tab pick up the pseudo instruction counter IC address and put on stack\par
\tab\tab\tab\tab    \tab bump the contents of that address by one \par
\tab\tab\tab\tab    \tab save the top word on the stack into the variable dictionary\par
\tab\tab\tab\tab\tab this stores instructions to variable dictionary and advances IC\par
\par
:INST OR DEPOSIT;          \tab (n m -- ) gen: (n OR m)\par
\tab\tab\tab\tab\tab OR the two words on the stack (to form an instruction) and DEPOSIT\par
\par
THE SECTION BELOW COVERS GENERATION OF VALID 1130 INSTRUCTIONS FOR COMPILED CODE\par
--------------------------------------------------------------------------------\par
:LD C000;                 \tab ( -- C000) gen: ()\par
\tab\tab\tab\tab\tab C000 is basis of 1130 Load Accumulator instruction\par
\par
:ST D000;                  \tab ( -- D000) gen: ()\par
\tab\tab\tab\tab\tab D000 is basis of 1130 Store Accumulator inst\par
\par
:ADD 8000;                 \tab ( -- 8000) gen: ()\par
\tab\tab\tab\tab\tab 8000 is basis of 1130 Add to Accumulator inst\par
\par
:SUB 9000;                 \tab ( -- 9000) gen: ()\par
\tab\tab\tab\tab\tab 9000 is basis of 1130 Subtract from Accumulator inst\par
\par
:MUL A000;                 \tab ( -- A000) gen: ()\par
\tab\tab\tab\tab\tab A000 is basis of 1130 Multiply Accumulator inst\par
\par
:DIV A800;                 \tab ( -- A800) gen: ()\par
\tab\tab\tab\tab\tab A800 is basis of 1130 Divide, into Accumulator+Extension inst\par
\par
:LX 6000;                  \tab ( -- 6000) gen: ()\par
\tab\tab\tab\tab\tab 6000 is basis of 1130 Load index register inst\par
\par
:SX 6800;                  \tab ( -- 6800) gen: ()\par
\tab\tab\tab\tab\tab 6800 is basis of 1130 Store index reg inst\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033 :MX 7000;                  \tab ( -- 7000) gen: ()\par
\tab\tab\tab\tab\tab 7000 with an IX specified is basis of 1130 Modify index reg inst\par
\par
:B 7000;                   \tab ( -- 7000) gen: ()\par
\tab\tab\tab\tab\tab 7000 with 0 IX specifiedis an 1130 short Branch inst\par
\par
:BL 4800;                  \tab ( -- 4800) gen: ()\par
\tab\tab\tab\tab\tab 4800 is basis of 1130 Branch long inst\par
\par
:BSI 4000;                 \tab ( -- 7=4000) gen: ()\par
\tab\tab\tab\tab\tab 4000 is basis of 1130 Branch and Store IAR (branch to subroutine) inst\par
\par
:XIO 800;                  \tab ( -- 0800) gen: ()\par
\tab\tab\tab\tab\tab 0800 is basis 1130 XIO (execute I/O) inst\par
\par
:X1 1000 OR;               \tab (n1 -- n1 OR 1000) gen: ()\par
\tab\tab\tab\tab\tab OR by 1000 adds value 01 to the index register field bits 6 and 7  \par
\tab\tab\tab\tab\tab thus it means IX1 is part of address computation of the instruction\par
\par
:X2 200 OR;                \tab (n1 -- n1 OR 2000) gen: ()\par
\tab\tab\tab\tab\tab OR by 2000 adds value 10 to the index register field bits 6 and 7  IX2\par
\par
:X3 300 OR;                \tab (n1 -- n1 OR 3000) gen: ()\par
\tab\tab\tab\tab\tab OR by 3000 adds value 11 to the index register field bits 6 and 7  IX3\par
\par
:MDM 7400 INST DEPOSIT;    \tab (n1 n2 -- )   gen: (7400 OR n2, n1)\par
\tab\tab\tab\tab\tab 7400 is the basis for a modify memory (long MDX with no register) \par
\tab\tab\tab\tab\tab Add/sub the displacement to a memory location. Entered with address\par
\tab\tab\tab\tab\tab of the memory location on stack, pushes MDM to variable then address\par
\par
:ZERO 1810 DEPOSIT;        \tab ( -- )     gen: (1810)\par
\tab\tab\tab\tab\tab 1810 is an 1130 shift right arithmetic 16 bits (clears word)\par
\par
:XCH 18D0 DEPOSIT;         \tab ( -- )     gen: (18D0)\par
\tab\tab\tab\tab\tab 18D0 is an 1130 rotate acc and ext 16 bits (exchange ACC and EXT contents)\par
\par
:I 480 INST DEPOSIT;       \tab (n1 n2 -- )  gen: (n2 OR 0480, n1)\par
\tab\tab\tab\tab\tab 0480 added to 1130 instruction sets long field (bit 5) and \par
\tab\tab\tab\tab\tab indirect address flag (bit 8), saves top of stack as address\par
\tab\tab\tab\tab\tab after saving indirect instruction.\par
\par
:L 400 INST;               \tab (n1 -- )   gen: (n1 OR 0400)\par
\tab\tab\tab\tab\tab 0400 added to 1130 instruction sets long field (bit 5) to indicate \par
\tab\tab\tab\tab\tab 32 bit instruction\par
\par
:LONG L DEPOSIT;           \tab (n1 n2 -- )  gen: (n2 OR 0400, n1)\par
\tab\tab\tab\tab\tab make an instruction long and stick in variable dictionary entry\par
\tab\tab\tab\tab\tab then stick top of stack (an address) in variable entry\par
\par
:STORE ST LONG;            \tab (n1 -- )    gen: (D400, n1)\par
\tab\tab\tab\tab\tab sticks a Store Accumulator long instruction in variable dictionary entry\par
\tab\tab\tab\tab\tab plus address is top of stack goes to variable entry\par
\par
:LOAD LD LONG;             \tab (n1 -- )   gen: (C400, n1)\par
\tab\tab\tab\tab\tab sticks a Load Accumulator long instruction in variable dictionary entry\par
\tab\tab\tab\tab\tab plus address is top of stack goes to variable entry\par
\par
:CALL BSI LONG;            \tab (n1 -- )   gen: (4400, n1)\par
\tab\tab\tab\tab\tab sticks a  BSI long instruction in variable dictionary entry\par
\tab\tab\tab\tab\tab plus address in top of stack goes to variable entry\par
\par
:ACC 1 B INST  DEPOSIT  FE INST;    (n1 n2 -- )  gen: (7001, n2, instruction OR n1)\par
\tab\tab\tab\tab\tab 1130 branch over next word put in variable dictionary entry, \par
\tab\tab\tab\tab\tab deposit first stack value as a constant into variable dictionary entry, \par
\tab\tab\tab\tab\tab then take stack-1 word as the beginning of an instruction, \par
\tab\tab\tab\tab\tab OR it with pattern 00FE to make it a short inst referencing \par
\tab\tab\tab\tab\tab our stored constant and deposit both into the dictionary entry\par
\tab\tab\tab\tab\tab Essentially puts a constant inline for use with an instruction on stack\par
\par
:GDEP IC 1 MDM  IC ST I;   \tab ( -- )   gen: (7401, IC, D480, IC)    bumps IC and stores ACC to new loc\par
\tab\tab\tab\tab\tab update IC (variable directory pointer) to next cell, \par
\tab\tab\tab\tab\tab create inst to bump the contents of that pointer by 1, \par
\tab\tab\tab\tab\tab then deposits the current accumulator content into new location\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189 :GOR  E800;\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch  
               \tab ( -- E800)  gen: ()\par
\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\tab\tab\tab\tab\tab 1130 logical O
R\par
\par
:GAND E000;                \tab ( -- E000)  gen: ()\par
\tab\tab\tab\tab\tab 1130 logical AND\par
\par
:GWAIT 3000 DEPOSIT;       \tab ( -- )  gen: (3000)\par
\tab\tab\tab\tab\tab 1130 Wait (halt) instruction\par
\par
:REL X3 LONG;              \tab (n1 n2 -- )  gen: (n2 OR 0700, n1)\par
\tab\tab\tab\tab\tab make instruction on stack long and using IX3\par
\par
:RELS X3 INST;             \tab (n -- )  gen: (n OR 0300)\par
\tab\tab\tab\tab\tab make instruction short and using IX3\par
\par
:BASE  LX REL;             \tab (n -- )  gen: (6700, n)\par
\tab\tab\tab\tab\tab Load IX register 3 (long instruction) with next word\par
\par
:BASA  1 ST INST  0 BASE;  \tab ( -- )  gen: (D001, 6700, hole)\par
\tab\tab\tab\tab\tab Store accumulator in next word of variable dictionary, \par
\tab\tab\tab\tab\tab deposit instruction to load IX 3 from that address\par
\par
:TOD 1880 INST;            \tab ( -- )  gen: (1880)\par
\tab\tab\tab\tab\tab shift right acc and ext arithmetic (sign bit stays untouched)\par
\par
:TOM 1000 INST;            \tab ( -- )  gen: (1000)\par
\tab\tab\tab\tab\tab shift left accumulator instruction\par
\par
:TXD 1880 INST;  \tab\tab\tab ( -- )  gen: (1880)\par
\tab\tab\tab\tab\tab shift right ACC and EXT arithmetically (sign stays untouched)\par
\tab\tab\tab\tab\tab presumably these will use IX for shift count (be ORed with IX code)\par
\par
:TXM 1080 INST;            \tab ( -- )  gen: (1080)\par
\tab\tab\tab\tab\tab shift left accum + extension instruction\par
\par
:TAD 1800 INST;            \tab ( -- )  gen: (1800)\par
\tab\tab\tab\tab\tab Shift right accumulator logical (sign bit moves too)\par
\par
:ZF  10A0 DEPOSIT;         \tab ( -- )  gen: (10A0)\par
\tab\tab\tab\tab\tab shift left ACC plus EXT 32 (zero out)\par
\par
:LF  ZF LOAD:              \tab ( -- )   gen: (10A0, C400, IC)\par
\tab\tab\tab\tab\tab zero out ACC and EXT, \par
\tab\tab\tab\tab\tab load current position in variable dictionary (IC)\par
\par
:FS  X2 INST;              \tab (n -- )   gen: (n OR 0200)\par
\tab\tab\tab\tab\tab Stores an instruction modified to use Index Register 2 (stack pointer)\par
\par
:LS  LD FS;                \tab (n -- )    gen: (C200 OR n)\par
\tab\tab\tab\tab\tab Load Stack - does a Load instruction w/ IX2\par
\par
:SS ST FS;                 \tab (n -- )    gen: (D200 OR n)\par
\tab\tab\tab\tab\tab Store stack - stores accumulator in stack (using IX2)\par
\par
:LSI LD X2 I;              \tab (n -- )    gen: (C680, n)\par
\tab\tab\tab\tab\tab Load indirect pointed to by stack (e.g. get value of address on stack)\par
\par
:SSI ST X2 I;              \tab (n -- )    gen: (D680, n)\par
\tab\tab\tab\tab\tab Store indirect pointed to by stack\par
\par
:MS  MX FS;                \tab (n -- )  gen: (6200 OR n)\par
\tab\tab\tab\tab\tab Modify the IX2 (stack pointer), should be ORed with displacement from stack\par
\par
:RETURN BL I;              \tab (n -- )  gen: (4C80, n)\par
\tab\tab\tab\tab\tab 1130 return from subroutine (Branch Long Indirect)\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033 ----------------------------------------------------\par
THE SECTION BELOW CREATES MAJOR FORTH OPERATORS in 1130 code\par
\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch ----------------------------------------------------\par
\'a2 CONSTANT E1 LX X3 I LD LOC LIT ACC\par
   2 ST X3 INST 0 LS 3 ST X3 INST  RETURN\tab\tab (n -- )   var: (\tab 6780, E1, 7001, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab execaddr(LITER), C0FE, D302, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab C203, D303, 4C80, return)\par
      \tab\tab Load IX3 Indirect with address of last used entry in fixed dictionary (E1)\par
\tab\tab\tab Look up execution address of LIT and load accumulator\par
\tab\tab\tab store this in word 2 of fixed dictionary entry\par
\tab\tab\tab load cell at top of stack (value of constant to save) == n\par
\tab\tab\tab store this in word 3 of fixed dictionary entry\par
\tab\tab\tab This will define a name and at execution stick the constant n on the stack\par
\par
\'a2 REVERT  E LOAD E1 STORE  E1 FC MDM RETURN\tab ( -- )   var: (C400, E, D400 E1, 74FC, E1, 4C80, return)\par
\tab\tab\tab load address of next free entry into accumulator, \par
\tab\tab\tab store it as the last used address E1, \par
\tab\tab\tab decrement last used entry address by 4\par
\tab\tab\tab regenerates the last used entry properly based on next free address\par
\par
\'a2 TOP E1 LOAD E STORE E 4 MDM RETURN\tab\tab ( -- )  var: (C400, E1, D400, E, 7404, E, 4C80, return)\par
\tab\tab\tab load last used entry into accumulator\par
\tab\tab\tab store it as the next free space\par
\tab\tab\tab bump up next free space by one entry\par
      \tab\tab regenerates the next free entry properly based on last used address\par
\par
\'a2 DUP 0 LS  1 MS  0 SS RETURN\tab\tab (n1 -- n1 n1)  var: (C200, 7201, D200, 4C80, return)\par
     \tab\tab\tab duplicate the value at top of stack. load top stack word to acc\par
\tab\tab\tab bump stack pointer up by 1 and \par
\tab\tab\tab store the acc into stack\par
\par
\'a2 VALUE 0 LSI 0 SS RETURN\tab\tab (n -- contents(n))  var: (C680, n, D200, 4C80, return)\par
     \tab\tab\tab load value pointed to by addr at top of stack using Load Indirect \par
\tab\tab\tab store in stack replacing address\par
\par
\'a2 DROP FF MS RETURN\tab\tab\tab (n -- )  var: (72FF, 4C80, return)\par
     \tab\tab\tab drop top item from stack by decrementing stack pointer by 1\par
\par
\'a2 RAISE 1 MS RETURN\tab\tab\tab ( -- x)  var: (7201, 4C80, return)\par
     \tab\tab\tab bump stack pointer by 1 to leave a hole and return to caller\par
\par
\'a2 SWAP 0 LS XCH FF LS 0 SS XCH FF SS RETURN\tab (n1 n2 -- n2 n1)  var: (C200, 18D0, C2FF, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D200, 18D0, D2FF, 4C80, return)\par
     \tab\tab\tab swap top two words in stack. load top of stack to accumulator\par
\tab\tab\tab rotate it to extension, load stack-1 to acc, store to stack,\par
\tab\tab\tab rotate ext back to acc, store to stack - 1\par
\par
:MSI LD SWAP ACC DUP ADD FS SS;\tab (n1 n2 -- stack+n1 + n2)  gen: (7001, n2, C0FE, 82n1, D2n1)\par
\tab\tab\tab Entered with two values on the stack (A and B) \par
     \tab\tab\tab Load instuction, swapped to stack-1,\par
\tab\tab\tab A value saved inline and used with LD instruction. \par
\tab\tab\tab adds stack + B to the accumulator\par
\tab\tab\tab stores result at stack + B (updates that position)\par
\par
\'a2 + 0 LS FF MS 0 ADD FS 0 SS RETURN      \tab\tab (n1 n2 -- n1+n2)  var: (C200, 72FF, 8200, \par
\tab\tab\tab\tab\tab\tab\tab\tab  \tab\tab\tab       D200, 4C80, return)\par
\tab\tab\tab load top of stack, decrement stack pointer, add new top of stack\par
\tab\tab\tab store result in new top of stack\par
     \tab\tab\tab add top two words and leave result at top of stack\par
\par
\'a2 AND 0 LS FF MS 0 E000 FS 0 SS RETURN\tab\tab (n1 n2 -- n1 AND n2) var: (C200, 72FF, E200, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    D200, 4C80, return)\par
     \tab\tab\tab and top two words and leave result at top of stack\par
\par
:DISP FF AND;\tab\tab\tab\tab\tab\tab (n -- low 8 bits of n) gen: (E0FF)\par
     \tab\tab\tab Disp will AND off top half of cell on stack to get displacement of short instruction\par
\par
\'a2 - FF MS 0 LS 1 SUB FS 0 SS RETURN \tab\tab (n1 n2 -- n2-n1)   var: (72FF, C200, 9201, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D200, 4C80, return)\par
\tab\tab\tab subtract top two words and leave result at top of stack\par
\par
\'a2 MINUS ZERO 0 SUB FS 0 SS RETURN   \tab\tab (n -- -n)  var: (1810, 9200, D200, 4C80, return)\par
\tab\tab\tab zero out accumulator, subtract top of stack and store result\par
\par
\'a2 / FF LS 1890 DEPOSIT 0 DIV FS FF SS XCH 0 SS RETURN (n1 n2 -- n2/n1)  var: (C2FF, 1890, A800, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    D2FF, 18D0, D200, 4C80, return)\par
\tab\tab\tab divide top two words and leave result at top of stack\par
\par
\'a2 * FF LS 0 MUL FS XCH FF MS 0 SS RETURN   \tab (n1 n2 -- n1*n2)  var: (C2FF, A000, 1890, 72FF, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   \tab D200, 4C80, return)\par
\tab\tab\tab multiply top two words and leave result at top of stack\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\'a2 PUSH 0 LSI ADD 1 ACC 0 SSI 0 SS FF LS 0 SSI\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich
\af189\afs20\alang1033\loch\par
    FE MS RETURN\tab\tab\tab\tab\tab (n1 n2 -- ) var: (C680, 0000, 7001, 0001, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab       80FE, D680, 0000, D200, C2FF, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab       D680, 0000, 72FE, 4C80, return)\par
\tab\tab\tab load value from address at top of stack (n2) to accumulator\par
\tab\tab\tab e.g. n2 is a pointer to head of user stack\par
\tab\tab\tab add 1 to the value in accumulator (advanced stack pointer)\par
\tab\tab\tab store result in location whose address is top of stack\par
\tab\tab\tab store also in stack+0 replacing original value of n2\par
\tab\tab\tab load stack - 1 (n1)\par
\tab\tab\tab store into location whose address is on stack one past original n2\par
\tab\tab\tab remove two items from stack \par
\tab\tab\tab top of stack is n2, a pointer to the user stack\par
\tab\tab\tab this bumps user pointer and stores n1 into the new location\par
\par
\'a2 PULL 0 LSI 1 SS SUB 1 ACC 0 SSI 1 LSI 0 SS RETURN\tab (n -- contents(n-1), contents(n)) \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab var: (C680, 0000, D201, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab 7001, 0001, 90FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab D680, 0000, C680, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab 0001, D200, 4C80, return)\par
\tab\tab\tab loads value in address n2 from stack (stack pointer)\par
\tab\tab\tab stores in stack + 1 (beyond top of stack)\par
\tab\tab\tab subtract 1 from accumulator (lowers user stack pointer value)\par
\tab\tab\tab store new stack pointer value in address n2\par
\tab\tab\tab pick up next value from user stack +1\par
 \tab\tab\tab store in top of stack\par
\tab\tab\tab this grabs n1 from stack, lowers pointer by 1\par
\tab\tab\tab has side effect of old value in stack+1\par
\par
:STACK 1 MS LOAD 0 SS;\tab\tab\tab\tab (n1 -- n1 n1) gen: (7201, C400, n, D200)\par
\tab\tab\tab bump stack pointer, load original top of stack and store in new position\par
\tab\tab\tab this is same as a DUP but not a callable routine, instead inline\par
\par
:LITS LD SWAP ACC 1 MS 0 SS;\tab\tab\tab (n1 -- n1 contents(n1)) gen: (7001, n, C0FE, 7201, D200 )\par
\tab\tab\tab load address n1 into accumulator, \par
\tab\tab\tab set up load instruction C000\par
\tab\tab\tab swap so stack is address n1 then c000\par
\tab\tab\tab stick address n as constant and load the contents (7001 n C0FE)\par
\tab\tab\tab bump top of stack\par
\tab\tab\tab store value of address n1 into new top of stack\par
\tab\tab\tab like VALUE but not callable, inline instead\par
\page\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\'a2 VECTOR 0 LS GDEP IC STACK LOC CONSTANT CALL\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20
\alang1033\loch\par
   FF ADD FS IC STORE FE MS RETURN\tab\tab\tab (n -- )  var: (C200, 7401, IC, D480, IC,\par
\tab\tab\tab\tab make space for the number of entries  7201, C400, IC, D200,\par
\tab\tab\tab\tab load top of stack to accumulator\tab    4400, CONSTANT, 82FF,\par
\tab\tab\tab\tab bump up IC by one and save n on stack D400, IC, 72FE, 4C80, return)\par
\tab\tab\tab\tab find execution address of CONSTANT\par
\tab\tab\tab\tab call CONSTANT to convert addr to value\par
\tab\tab\tab\tab add n to IC and store into IC, pull 2 from stack\par
\tab\tab\tab\tab When executed, it pushes the current IC onto variable\par
\tab\tab\tab\tab dictionary entry then reserves n cells by bumping IC\par
\par
:XS 4 VECTOR; \tab\tab ( -- )  gen: ()\par
\tab\tab\tab\tab define XS as a four deep vector.\par
\par
XS XS XS=\tab\tab\tab ( -- )  var (address of XS, 0000, 0000, 0000, 0000)\par
\tab  \tab\tab\tab create one XS vector\par
\par
:TRANSIENT IC INC XS PUSH;\tab\tab\tab ( -- )  gen: ()\par
\tab\tab\tab\tab get address of current variable entry, bump by 1,\par
\tab\tab\tab\tab push this value into the XS stack\par
\tab\tab\tab\tab this sets up temp code into XS stack to be executed\par
\par
\'a2 EXECUTE LD BL 480 OR ACC GDEP XS LD I GDEP ( -- )  var: (7001, 4C80, C0FE, 7401, 0D83,\par
   XS LX X3 I 0 BSI X3 I XS LITS LOC PULL CALL\tab\tab\tab D480, 0D83, C480, XS, 7401, 0D83,\par
   SUB 1 ACC IC STORE FF MS RETURN\tab\tab\tab\tab\tab D480, 0D83, 6780, XS, 4780, 0000,\par
\tab\tab\tab\tab as this executes, it pushes\tab\tab 7001, XS, C0FE, 7201, D200,\par
\tab\tab\tab\tab 4C80 in variable dictionary,\tab\tab 4400, PULL, 7001, 0001, 90FE,\par
\tab\tab\tab\tab loads address of XS vector\tab\tab D400, IC, 72FF, 4C80, return)\par
\tab\tab\tab\tab stores that in variable dictionary\par
\tab\tab\tab\tab loads IX3 with first word of XS\par
\tab\tab\tab\tab Calls routine pointed to by IX3\par
\tab\tab\tab\tab loads XS to accumlator\par
\tab\tab\tab\tab bump stack and store XS there\par
\tab\tab\tab\tab Calls PULL routine\par
\tab\tab\tab\tab Subtracts 1 from accumulator\par
\tab\tab\tab\tab Store as IC\par
\tab\tab\tab\tab drop top of parameter stack\par
\tab\tab\tab\tab This will execute routine at top of XS stack\par
\tab\tab\tab\tab then pull from XS stack\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033 :BACK IC VALUE - DISP B INST;\tab\tab (n -- )  gen: (B relative IC - n)\par
\tab\tab\tab\tab stick address of IC on stack, replace with contents\par
\tab\tab\tab\tab subtract that from n which is stack-1\par
\tab\tab\tab\tab AND with 00FF to get 8 bit signed integer\par
\tab\tab\tab\tab OR together 7000 (Branch) and displacement, \par
\tab\tab\tab\tab stick this branch relative on variable dictionary\par
\par
:MARK IC VALUE SWAP LX X3 INST; \tab (n -- IC of LX instruction)  gen: (7201, 63nn)\par
\tab\tab\tab\tab push IC address on stack, replace with contents\par
\tab\tab\tab\tab swap n and IC contents  - stack now IC, n\par
\tab\tab\tab\tab builds LX 6000, IX3, and n\par
\tab\tab\tab\tab push that 63nn instruction to variable dictionary\par
\tab\tab\tab\tab This updates IC to point to next free location\par
\tab\tab\tab\tab and loads IX3 with a count (n)\par
\par
:LOOP FF MX X3 INST BACK;\tab\tab ( -- )  gen: (73FF, B relative to marked instruction)\par
\tab\tab\tab\tab modify IX3 as loop counter\par
\tab\tab\tab\tab branch back unless it becomes\par
\tab\tab\tab\tab zero or neg, then skip branch\par
\tab\tab\tab\tab and branch back to last IC address\par
\par
:START 2 B INST DEPOSIT IC INC\tab (n -- )  gen: (7201, 7002, n, C0FE, C0FD, D0FD)\par
   FD LD INST FD ST INST;   ????\par
\tab\tab\tab\tab Branch over next two cells in variable dictionary\par
\tab\tab\tab\tab save top of stack in variable dictionary as one word\par
\tab\tab\tab\tab second word is empty\par
\tab\tab\tab\tab increment IC value, Load first word in accumulator\par
\tab\tab\tab\tab Store into second word of the entry\par
\par
:STOP DUP FF MDM 1+ BACK;\tab\tab (n -- )  gen: (74FF, n, 70back to ) \par
\tab\tab\tab\tab duplicate top of stack, decrement that address,\par
\tab\tab\tab\tab add 1 to the duplicated value and branch back\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033 :CONDITION 0 LS FF MS BSI OR L LOC NEXT DEPOSIT RETURN;  (n1 n2 -- )  gen: (7201, C200, 72FF, \par

\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab  44nn, NEXT, 4C80, return)\par
\tab\tab\tab\tab builds up and executes a branch conditional, which will call NEXT\par
\tab\tab\tab\tab to fetch another word if condition is matched\par
\par
\'a2 NONZERO 18 CONDITION\tab\tab\tab (n -- )  var: (7201, C200, 72FF, 4418, NEXT, 4C80, return)\par
\tab\tab\tab\tab branch conditional flags for nonzero test\par
\par
\'a2 FALSE 20 CONDITION\tab\tab\tab (n -- )  var: (7201, C200, 72FF, 4420, NEXT, 4C80, return)\par
\tab\tab\tab\tab branch conditional flags for notequal test\par
\par
\'a2 EVEN 04 CONDITION\tab\tab\tab (n -- )  var: (7201, C200, 72FF, 4404, NEXT, 4C80, return)\par
\tab\tab\tab\tab branch conditional flags for even test\par
\par
:IF BL 400 OR INST IC INC;  \tab\tab\tab (n -- )  gen: (4Cnn, IC+1)\par
\tab\tab\tab\tab uses top of stack as condition for branch conditional long, \par
\tab\tab\tab\tab branch is to next logic instruction on variable dictionary\par
\par
:THEN IC VALUE 1+ SWAP=;\tab\tab\tab (n -- )  gen: ()\par
\tab\tab\tab\tab gets value of current IC, bumps by 1, swaps with TOS n\par
\tab\tab\tab\tab and stores that word in new IC location \par
\par
:ELSE IC VALUE 3+ SWAP= 0 IF;\tab\tab\tab (n -- )  gen: ()\par
\tab\tab\tab\tab get value of current IC, bump by 3, swap and store n there\par
\tab\tab\tab\tab set condition of 0 in stack and implement IF\par
\par
:POSITIVE 8;  \tab\tab\tab\tab\tab ( -- 9)  gen: ()\par
\par
:NEGATIVE 10; \tab\tab\tab\tab\tab ( -- 10)   gen: ()\par
\par
:EQUAL 20;  \tab\tab\tab\tab\tab ( -- 20)   gen: ()\par
\par
:NOT 18;\tab\tab\tab\tab\tab\tab ( -- 18)   var: ()\par
\par
:PROGRAM 1 B INST 0 DEPOSIT;  \tab\tab ( -- )  var: (7001, 0)\par
\tab Stick in a branch over next word\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033\'a2 QUEUE 1- PROGRAM GWAIT BACK\tab\tab  \tab ( -- )  var: (0000, 7001, 0929, 3000, 70FC)\par
\tab branch over saved word unless this op code is altered\par
\tab issue 1130 WAIT instruction\par
\tab loop back to wait again\par
\tab caller ENQUEUE will update the word 0000 to be an address and word 1 as an instruction\par
\tab I suspect that the 0929 was pushed in by a caller to ENQUEUE\par
\tab\par
:ENQUEUE LOAD LOC QUEUE 2+ STORE\tab\tab (n -- )  \tab var: (C400, n, D400, queue+2, 7001, 7001, C0FE, \par
   LD 1 B OR ACC LOC QUEUE 1+ STORE LOC QUEUE 1+ BL LONG;  D400, queue+1, 4C00, queue+1, 4C80, return )\par
\tab\tab\tab picks up address n from stack and loads its contents\par
\tab\tab\tab store content of address in QUEUE word 2\par
\tab\tab\tab load 7001 (B 1 instruction)\par
\tab\tab\tab store in QUEUE word 1\par
\tab\tab\tab Branch to QUEUE, then return\par
\par
:REACTIVATE LD BL 400 OR ACC LOC QUEUE 1+ STORE;  ( -- )  var: (7001, 4C00, C0FE, D400, queue+1)\par
\tab\tab\tab will plug a branch long into word 1 of queue, causing a branch to \par
\tab\tab\tab the address that was previously stored in word 2 of queue by ENQUEUE\par
\par
:BNZ BL 20 OR;\tab\tab\tab\tab\tab ( -- 4820)  var: ()\par
\tab\tab\tab sets up the first word of a branch long instruction with condition 20\par
\par
:BUFFER DUP DUP DUP DUP VALUE 2/ DROP+ 2+\tab (n -- )  var: ()\par
   SWAP 1+= 2+ SWAP=;\par
\tab\tab\tab is passed an address of a buffer which has a length in n - characters, 2X words\par
\tab\tab\tab This will get the address from the first word and fetch its value\par
\tab\tab\tab divide length by 2 to get words, then add 2 to form the address of tne next line\par
\tab\tab\tab That address of the next line is stored in n+1 location then n is \par
\tab\tab\tab updated to point to n+2 (skipping over the pointer to next line)\par
\tab\tab\tab this would be used to manage lines in a disk buffer\par
\tab\tab\tab\par
\'a2 EXCHANGE 0 LS ADD 1 ACC 1 SS 0 LSI   \tab (n -- )  var: (0000, C200, 7001, 0001, 80FE, D200, \par
   XCH 1 LSI 0 SSI XCH 1 SSI FF MS RETURN\tab\tab\tab    C680, 0000, 18D0, C680, 0001, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab    D680, 0000, 18D0, D680, 0001, 72FF, 4C80, return)\par
\tab\tab\tab passed in an address on stack, will bump up n by 1 and save it at stack + 1 (temp)\par
\tab\tab\tab then swaps the two values at stack and stack+1\par
\tab\tab\tab finally, drops original value from stack and returns\par
\tab\tab\tab Pass address of two word area and swap the values in those locations. \par
\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033 :CLEAR LOAD 4840 I;       \tab\tab\tab (n1 n2 -- )  var: (C400, n2, 4CC0, n1)\par
\tab\tab\tab will produce code on variable dictionary stack to load the value at address n2\par
\tab\tab\tab and BOSC back to n1 (BOSC resets any pending interrupts)\par
\par
:NOP B DEPOSIT;\tab\tab\tab\tab\tab ( -- )  var: (7000)\par
\tab\tab\tab produces a NOP on the variable dictionary stack\par
\par
\par
:ALIGN IC VALUE EVEN NOP;\tab\tab\tab ( -- )  var: (either 7000 or nothing)\par
\tab\tab\tab fetches IC address then its value (next location in variable dictionary)\par
\tab\tab\tab does an even condition, e.g if the value is even, gobble up next word\par
\tab\tab\tab before it is processed. Thus, if odd, NOP is interpreted\par
\par
:GXIO ALIGN 1 XIO INST 2 B INST DEPOSIT DEPOSIT; (n1 n2 -- )  var: (align with 7000 if needed, \par
\tab\tab\tab First aligns to an even (doubleword) address\tab    0801, 7002, n2, n1)\par
\tab\tab\tab the issues XIO pointing at two words on stack \par
\tab\tab\tab which are the IOCC, then branch over the IOCC\par
\par
:WTC 1+ 2*;\tab\tab\tab\tab\tab\tab (n -- 2*(n+1))  var: ()\par
\tab\tab\tab calculates (n+1)*2 and leaves on stack\par
\tab\tab\tab converts word address to pseudo character address (2x real address)\par
\tab\tab\tab used with verbs that access packed character fields\par
\par
\'a2 FILL 0 LS FF MS 1 ST INST 0 START LOC NEXT CALL\tab (n -- )  var: (0000, C200, 72FF, D001, \par
   LOC HEX CALL 0 LS GDEP FF MS STOP RETURN\tab\tab\tab\tab    7002, 0040, 0000 (target), \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    C0FD, D0FD, 4400, next, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    4400, hex, C200, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    7401, IC, D480, IC, 72FF, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    74FF, target, 70F3, 4C80, return)\par
\tab\tab\tab removes n from stack, stores it as starting count\par
\tab\tab\tab loads 0040 (template) but actually n2 and stores it in target variable\par
\tab\tab\tab grabs next word from stream \par
\tab\tab\tab makes it a hex constant on stack\par
\tab\tab\tab load that constant from stack, bump IC, \par
\tab\tab\tab stick on variable dictionary, drop from stack, \par
\tab\tab\tab decrement target and loop until it hits zero then return\par
\par
:DATA IC VALUE 1+ CONSTANT DROP;\tab\tab ( -- )  var: () \par
\tab\tab\tab this is an odd duck. it picks up the address of the next entry\par
\tab\tab\tab of the variable dictionary (value of IC), bumps it, saves that\par
\tab\tab\tab in stack + 1 but does not increment stack thus it is invisible\par
\par
:CSKB 40 DATA FILL 2000 1000 800 400 200 100 80 40 20 10 \tab ( -- )  gen: (call FILL to set up 64 char table)\par
9000 8800 8400 8200 8100 8080 8040 8020 8010 5000 4800 4400 4200 4100\par
4080 4040 4020 4010 2800 2400 2200 2100 2080 2040 2020 2010 0000\par
8820 0420 8220 8120 80A0 8060 8000 4820 4420 4220 4120 40A0 4060\par
4000 3000 2420 2220 2120 20A0 2060 0820 8420 0220 0120 00A0 0060\par
0000; \par
\par
CSKB\tab\tab\tab\tab\tab\tab\tab ( -- )  var: (Data area CSKB with these values)\par
\tab\tab This is a table of hollerith code constants, with rows 12, 11, 0 then 1 to 9 \par
\tab\tab left justified in each word. The relative position corresponds to Forth code,\par
\tab\tab for example the letter A is the value x0A in FORTH code, the tenth entry\par
\tab\tab here, 9000, which signifies a 12 and a 1 punch\par
\par
:CSCP 40 DATA FILL C400 FC00 D800 DC00 F000 F400 D000 D400 E400 E000  \tab ( -- )  gen: (call FILL to set\par
3C00 1800 1C00 3000 3400 1000 1400 2400 2000 7C00 5800 5C00 7000\tab\tab\tab\tab   up 64 char table)\tab\par
7400 5000 5400 6400 6000 9800 9C00 B000 B400 9000 9400 A400 A000\par
2100 0200 C000 DE00 FE00 DA00 C600 4400 4200 4000 D600 F600 D200\par
F200 8400 BC00 8000 0600 BD00 4600 8600 8200 0000 0400 E600 C200\par
E200 8600; \par
\par
CSCP\tab\tab\tab\tab\tab\tab\tab ( -- ) gen: (data area CSCP with these values\par
\tab\tab This is a table of Selectric PTTC/8 constants, 8 bits left justified \par
\tab\tab The relative position corresponds to Forth code,\par
\tab\tab for example the letter A is the value x0A in FORTH code, the tenth entry\par
\tab\tab here, 3C00, causes the typeball to tilt and rotate to type an A\par
\par
:A 2 VECTOR; \tab\tab\tab\tab\tab ( -- )  gen: (size cell plus 2 cells)\par
\par
A\tab\tab\tab\tab\tab\tab\tab ( -- )  var: (2 word vector stored in variable \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab   dictionary under name A)\par
\par
:RESTORE A 2+ STORE 0F01 0 GXIO;\tab\tab ( -- )  gen: (D400, A(2), optional NOP,  0801, 7002, 0000, 0F01)\par
\tab\tab This will store the accumulator contents in the second word of vector A, then \par
\tab\tab builds code to issue an XIO instruction with IOCC 0000 0F01 which clears status of console\par
\par
:CONTINUE A 2+ CLEAR;\tab\tab\tab\tab (n -- )  gen: (C400, A(2), 4CC0, n)\par
\tab\tab This will load word 2 of vector A into the accumulator\par
\tab\tab then will branch indirect (return) to address in n, with the interrupt\par
\tab\tab level clear bit on. This is the normal return from an interrupt handle\par
\par
\'a2 READY RESTORE REACTIVATE CONTINUE\tab\tab (n -- )  var: (D400, A(2), optional NOP, 0801, \par
\tab\tab\tab\tab\tab\tab\tab\tab          7002, 0000, 0F01, 7001, 4C00, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab    D400, queue+1, C400, A(2), 4CC0, n)\par
\tab\tab saves accumulator in word 2 of vector A, clear the console, \par
\tab\tab clear out the QUEUE, reload the saved accumulator and BOSC back\par
\par
:CHA A 1+ STORE 0900 A 1+ GXIO LD LOC READY ACC 0C STORE,\tab ( -- )  gen: (D400, A(1), optional NOP, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   0801, 7002, A(1), 0900, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab         7001, ready, C0FE, D400, 000C)\par
\tab\tab store accumulator in first word of vector A, \par
\tab\tab issue XIO to type character in address in A(1) to console printer\par
\tab\tab look up address of READY verb and load it to accumulator \par
\tab\tab then set it up as interrupt level handler for IL4\par
\tab\tab thus READY is the IL4 interrupt handler during typing\par
\tab\tab this should be called and then pause FORTH with ENQUEUE\par
\tab\tab\par
\par
\'a2 CHARACTER RESTORE 0A00 A 1+ GXIO A 1+ LOAD\tab\tab ( -- )  var: (0000, D400, A(2), \par
   ST X1 DEPOSIT LOC CONVERT CALL CSCP LD REL CHA CONTINUE\tab               optional NOP, 0801, 7002, 0000, \tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   0F01, 0801, 7002, A(1), 0A00,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   C400, A(1), D100, 4400, conve,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   C700, CSCP, D400, A(1), \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   optional NOP, 0801, 7002, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   A(1), 0900, 7001, ready, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   C0FE, D400, 000C, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   C400, A(2), 4CC0, return)\tab\tab\par
\tab\tab this routine processes each character as it is keyed on console\par
\tab\tab acting as the IL4 interrupt handler after a console read has been issued\par
\tab\tab the system should be waiting with ENQUEUE for this\par
\par
\'a2 ACCEPT LD LOC CHARACTER ACC 0C STORE 0C00 0 GXIO ENQUEUE ( -- )  var: (0000, 7001, character, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, 000C, optional NOP, 0801, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   7002, 0000, 0C00, C400, accept, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, queue+2, 7001, 7001, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, queue+1, 4C00, queue+1)\par
\tab\tab load the address of CHARACTER, the IL4 interrupt level routine\par
\tab\tab then store it in 000C to make it active. Issue a read on the \par
\tab\tab console keyboard and wait  for completion\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033\'a2 CONSOLE LD CSKB 3F+ ACC FF ST X1 INST LD LOC ACCEPT ACC\tab ( -- )  var: (0000, 7001, CSKB+3
F, C0FE, \par
   FE ST X1 INST RETURN\tab\tab\tab\tab\tab\tab\tab\tab\tab   D1FF, 7001, accept, COFE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D1FE, 4C80, return)\par
\tab\tab load address of the end of the keyboard translation table into accumulator\par
\tab\tab store in work area -1 (character table). load the address of ACCEPT\par
\tab\tab routine and store in work area -2 (accept). return to caller\par
\tab\tab this sets up the parser to read and convert from the console\par
\par
\'a2 TYP CHA ENQUEUE\tab\tab\tab\tab\tab\tab ( -- )  var: (0000, D400, A(1), optional NOP, 0801, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   7002, A(1), 0900, 7001, ready, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, 000C, 7001, typ, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, queue+2, 7001, 7001, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, queue+1, 4C00, queue+1)\par
\tab\tab takes word in accumulator and types to console, waiting until it is done\par
\par
:RED 900;  \tab\tab\tab\tab\tab\tab\tab ( -- 0900)  gen: ()\par
\tab\tab stores in stack character code to shift the console printer to red ribbon\par
\par
:BLACK 500;\tab\tab\tab\tab\tab\tab\tab ( -- 0500)  gen: ()\par
\tab\tab stores in stack character code to shift the console printer to black ribbon\par
\par
\'a2 RIBBON 0 LS FF MS LOC TYP CALL LD 8100 ACC\tab (n -- )  var: (0000, C200, 72FF, 4400, typ, \par
  LOC TYP CALL RETURN\tab\tab\tab\tab\tab\tab\tab    7001, 8100, C0FE, 4400, typ, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    4C80, return)\par
\tab\tab loads the top of stack as a selectric typewriter code and calls TYP to output it,\par
\tab\tab then sets up selectric code for CR and calls TYP to output it\par
\par
\'a2 TYPE\tab\tab\tab\tab\tab\tab\tab (n1 n2 -- )  var: (0000, C200, D001, 7002, 0008 (init),      \par
  0 LS 1 ST INST 0 START FF LS LOC FETCH CALL\tab\tab\tab    \tab  0000 (index), C0FD, D0FD, C2FF (loop), \par
     BASA SUB 3F ACC POSITIVE IF 3F BASE THEN\tab\tab\tab   \tab  4400, fetch, D001, 6700, 000E, \par
  CSCP LD REL LOC TYP CALL FF 1 MSI STOP FE MS RETURN\tab\tab   \tab  7001, 003F, 90FE, 4C08, skip, 6700, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab  003F, C700 (skip), cscp, 4400, typ, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab  7001, 0001, C0FE, 82FF, D2FF, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   \tab  74FF, index, 70E7 (B to loop), \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab        72FE, 4C80, return)\par
\tab\tab Call with memory location and length in stack, will type out the contents as characters\par
\tab\tab load top of stack n2, update init location,\tab set index to initial value (0008 replaced by TOS)\par
\tab\tab load n1, call fetch routine store over 000E, load IX3 with result of fetch,\par
\tab\tab subtract 003F. If positive, load IX3 with 003F, then load CSCP + IX3,\par
\tab\tab call typ to type the character, load 1, add n1, store as n1, reduce index by 1,\par
\tab\tab return to loop again. Once index goes to zero, drop two stack values and return\par
\par
:MESSAGE BLACK RIBBON TYPE RED RIBBON;\tab\tab (n1 n2 -- )  gen: ()\par
\tab\tab will set ribbon to black, do CR, type characters from n1 for length n2\par
\tab\tab then set ribbon to red and do another CR\par
\par
:ALPHA 14 VECTOR; \tab\tab\tab\tab\tab ( -- )  gen: (load 14 instack and execute VECTOR)\par
\par
ALPHA\tab\tab\tab\tab\tab\tab\tab\tab ( -- )  var: (instantiate vector ALPHA, 0008 + 14 cells)\par
\par
:REPLY ALPHA WTC ALPHA VALUE MESSAGE;\tab\tab ( -- )  gen: ()\par
\tab\tab converts address of alpha from word to character (2x) and put on stack\par
\tab\tab sticks size of alpha on stack\par
\tab\tab calls message\par
\par
:D 3 VECTOR; \tab\tab\tab\tab\tab\tab ( -- )  gen: (load 3 in stack and call VECTOR)\par
\par
D\tab\tab\tab\tab\tab\tab\tab\tab ( -- )  var: (instantiate D as 0003 and 3 cells)\par
\tab\tab D(1) holds current track number\par
\par
:QUERY 8F01 0 GXIO;\tab\tab\tab\tab\tab ( -- )  gen: (optional NOP, 0801, 7002, 0, 8F01)\par
\tab\tab does an XIO to fetch disk2 status (DSK1 of simulator) and reset conditions\par
\par
\'a2 DONE D STORE QUERY REACTIVATE D CLEAR\tab\tab ( -- )  var: (0000, D400, D, optional NOP, 0801, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   7002, 0000, 8F01, 7001, 4C00, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, query+1, C400, D, 4CC0, return)\par
\tab\tab This is the interrupt handler that saves and restores the accumulator in D\par
\tab\tab then reads and resets disk status, restores the queue and does a BOSC out of interrupt\par
\par
\'a2 HOME ZERO D 1+ ST LONG QUERY GAND 0800 ACC\tab ( -- )  var: (0000, 1810, D400, D(1), optional NOP, 0801, \par
   DUP BNZ I 8C04 C8 GXIO ENQUEUE\tab\tab\tab\tab\tab   7002, 0000, 8F01, 7001, 0800, E0FE,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   4CA0, return, optional NOP, 0801, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   7002, 00C8, 8C04, C400, home, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, query+2, 7001, 7001, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, query+1, 4C00, query+1)\par
\tab\tab This zeroes the accumulator, tests the status of disk 2 (DSK1 in simulator)\par
\tab\tab verifies bit 4 (carriage home) to test if the drive is at track 0 already\par
\tab\tab if not, it issues a seek backwards to ensure it is at the home location\par
\tab\tab sticking the address of this routine in the queue and lets it wait until\par
\tab\tab the disk command finishes\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033 :IN 154 VECTOR; \tab\tab\tab\tab ( -- )  gen: (sticks 154 on stack and calls VECTOR)\par
\par
IN 141 IN=\tab\tab\tab\tab\tab ( -- )  var: (instantiates IN as 154 cell vector, the\par
\tab\tab\tab\tab\tab\tab\tab\tab   stores 141 in the first cell\par
\par
:BZ BL 18 OR;\tab\tab\tab\tab ( -- 4818)  gen: ()\par
\tab\tab\tab produces a branch long condition (branch on zero) into stack\par
\par
:M LD;  \tab\tab\tab\tab\tab ( -- C000)  gen: ()\par
\tab\tab\tab produces a load instruction into stack\par
\par
:CS MS;  \tab\tab\tab\tab\tab ( -- 7200)  gen: ()\par
\tab\tab\tab produces a modify stack (MDX IX2 into stack\par
\par
:ZLT ZERO;\tab\tab\tab\tab\tab ( -- )  gen: (1810)\par
\tab\tab\tab produces a shift left A+E 32 instruction (zeroes ACC and EXT) into variable dictionary\par
\par
:TS SS; \tab\tab\tab\tab\tab (n -- )  gen: (D2nn)\par
\tab\tab\tab produces a store stack STO IX2 instruction into variable dictionary\par
\par
:TM STORE; \tab\tab\tab\tab\tab (n -- )  gen: (D400, n)\par
\tab\tab\tab produces a store long instruction onto variable dictionary entry\par
\par
:TR ST INST; \tab\tab\tab\tab (n -- )  gen: (D0nn)\par
\tab\tab\tab produces a store instruction relative n onto variable dictionary\par
\par
:TA ST REL;\tab\tab\tab\tab\tab (n -- )  gen: (D700, n)\par
\tab\tab\tab produces a store instruction to IX3 plus n, put onto variable dictionary\par
\par
:ST FS; \tab\tab\tab\tab\tab (n1 n2 -- )  gen: (n1 OR 0200, n2)\par
\tab\tab\tab produces an instruction of type n1 to address n2 using IX2 onto variable dictionary\par
\par
:MT LONG; \tab\tab\tab\tab\tab (n1, n2 -- )  gen: (n2 OR 0400, n1)\par
\tab\tab\tab produces a long instruction of type n2, address n1, onto variable dictionary\par
\par
:RT INST; \tab\tab\tab\tab\tab (n1 n2 -- )  gen: (n1 OR n2)\par
\tab\tab\tab produces an n1 instruction with relative displacement n2 onto variable dictionary\par
\par
:AT REL;  \tab\tab\tab\tab\tab (n1 n2 -- )  gen: (n2 OR 0700, n1)\par
\tab\tab\tab produces a long instruction using IX3 onto variable dictionary\par
\par
:LT SWAP ACC;\tab\tab\tab\tab (n1 n2 -- )  gen: (7001, n1, n2FE)\par
\tab\tab\tab This will apply an n2 instruction against the constant n1\par
\par
:FIXUP 6 M RT 3 TAD 3 TXM 3 TR;\tab ( -- )  gen: (C006, 1803, 1083, D003) \par
\tab\tab\tab this will be part of the next verb, where it grabs a \par
\tab\tab\tab value later in the verb entry, clears the top and bottom\par
\tab\tab\tab two bits and replaces the value it had fetched\par
\par
\'a2 CYLINDER 3 TOD 2 TS D 1+ SUB MT DUP BZ I\tab (n -- )  var: (0000, 1883, D202, 9400, D(1), 4C98, return,\par
   POSITIVE IF 3 TOM 3 TXD\tab\tab\tab\tab\tab\tab    4C08, else, 1003 (if), 1883, 4C00, then,\par
   ELSE 1 TS 10 TXD ZLT 1 SUB ST\tab\tab\tab\tab\tab    D201 (else), 1890, 1810, 9201, \par
   THEN ALIGN NOP 6 TR\tab\tab\tab\tab\tab\tab\tab    7000 (then), 7000, D006, C006,\par
   FIXUP 8C00 0 GXIO 2 M ST D 1+ TM\tab\tab\tab\tab\tab    1803, 1083, D003, 0801, 7002,\par
   8 M LT D 2+ TM ENQUEUE\tab\tab\tab\tab\tab\tab    0000, 8C00, C202, D400, D(1), 7001, 0008, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    C0FE, D400, D(2), C400, cylinder, D400,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    queue+2, 7001, 7001, C0FE, D400, queue+1,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    4C00, queue+1\par
\tab\tab\tab shift accumultor contents right 3, converting sector to cylinder, store in stack+2, \par
\tab\tab\tab this was called from SECTOR who has sector number n at top of stack, so\par
\tab\tab\tab this temporarily uses stack+1 and stack+2 as work areas\par
\tab\tab\tab subtract D(1), return if not positive (think this is a limit check, 2E0 or higher sector)\par
\tab\tab\tab if not positive, go to else\par
\tab\tab\tab if positive, Shift ACC left 3, shift ACC+E right 3, go to then\par
\tab\tab\tab else - store stack+1, swap, zero acc, subtract stack+1, go to then\par
\tab\tab\tab then - store in location IOCC word 1, the number of cylinders\par
\tab\tab\tab load from IOCC word 2 (command), shift both right 3 and left both 3\par
\tab\tab\tab store as command word, XIO with newly created seek IOCC,\par
\tab\tab\tab load stack+2, store in D(1) which I believe is current track\par
\tab\tab\tab load 0008 and store in D(2), stick cylinder and 7001 in queue \par
\tab\tab\tab to wait until the seek I/O completes\par
\tab\tab\tab\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033\'a2 SECTOR 0 M ST LOC CYLINDER CALL 0 M ST FF CS\tab (n -- )  var: (0000, C200, 4400, cylinder, 
C200, 72FF,\par
   7 GAND LT 1 TS D 2+ SUB MT DUP BZ I 1 M ST D 2+ TM\tab\tab    7001, 0007, E0FE, D201, 9400, D(2), \par
   3 TXD ALIGN FIXUP 8E00 IN GXIO ENQUEUE\tab\tab\tab\tab    4C98, sector, C201, D400, D(2), 1883,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    7000, C006, 1803, 1083, D003, 0801, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    7002, in, 8E00, in, C400, sector,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    D400, queue+2, 7001, 7001, C0FE, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab    D400, queue+1, 4C00, queue+1\par
\tab\tab\tab take n off stack and call cylinder\par
\tab\tab\tab return, top of stack is sector number\par
\tab\tab\tab drop n from stack\par
\tab\tab\tab AND 0007 with sector number to get\par
\tab\tab\tab head and sector within track\par
\tab\tab\tab load n once again and store in D(2)\par
\tab\tab\tab shift right 3 to get pure cylinder number\par
\tab\tab\tab load buffer address, shift left and right by 3\par
\tab\tab\tab and store in IOCC word 1 then do XIO to initiate read\par
\tab\tab\tab this reads in 141 words (full sector of disk, first\par
\tab\tab\tab word is sector number then 320 cells of data)\par
\tab\tab\tab put SECTOR command in queue and jump to wait till I/O done\par
\par
\'a2 WRITE D 2+ M MT 3 TXD ALIGN FIXUP 8D00 IN GXIO ENQUEUE\tab ( -- )  var: (0000, C400, D(2), 1883, 7000,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   C006, 1803, 1083, D003, 0801, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   7002, in, 8D00, C400, write,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, queue+2, 7001, 7001, C0FE,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D400, queue+1, 4C00, queue+1)\par
\tab\tab\tab load D(2), shift right 3 in accumulator\par
\tab\tab\tab load buffer address IN, shift right then left 3\par
\tab\tab\tab and save in IOCC word 1. XIO to Initiate Write\par
\tab\tab\tab stick address of WRITE in queue+2 and 7001 in \par
\tab\tab\tab queue+1, then jump into wait routine (QUEUE)\par
\tab\tab\tab This writes the buffer IN to disk\par
\par
:CHARACTER FFFE BSI X1 I FD M X1 RT 1 ADD LT FD X1 TR;\tab ( -- )  gen: (4580, FFFE, C1FD, 7001, 0001, 80FE, \tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   D1FD)\par
\tab\tab\tab call routine at workarea (IX1)-2, the accept routine\par
\tab\tab\tab load IX1 with current character pointer (workarea-3)\par
\tab\tab\tab add 1 to tht value and store back in workarea-3\par
\tab\tab       This will accept a character from the current input stream,\par
\tab\tab\tab which is disk or console, bumping the character pointer\par
\par
\s1\hyphpar1\rtlch\af0\afs20\alang1033\ltrch\dbch\af9\afs20\alang1033\hich\af0\afs20\alang1033\loch\f0\lang1033\par
\page\s5\hyphpar0\rtlch\af189\afs20\alang1033\ltrch\dbch\af189\afs20\alang1033\hich\af189\afs20\alang1033\loch\f189\lang1033 :REP FE M ST 2 TR 0 M X1 RT 3C SUB LT SWAP DUP BZ I SWAP   (n1 n2 n3 -- n1 n2 n3)  gen: (C2FE, D
002, C100, \par
   0 M ST DEP CALL 0 1 MSI;\tab\tab\tab\tab\tab\tab\tab\tab    \tab  \tab\tab 7001, 003C, 90FE, \tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab   \tab\tab\tab 4C98, n1, C200,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab  \tab\tab 4400, deposit, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab  \tab\tab 7001, 0001, C0FE,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab  \tab\tab 8200, D200)\par
\tab\tab\tab n1 is the test character\par
\tab\tab\tab n2 is the routine to branch to if the character is a match\par
\tab\tab\tab n3 is a character to deposit as a replacement\par
\tab\tab\tab grab stack -2 (n1) and store as test character (replace 3C)\par
\tab\tab\tab load current character (IX1 is workarea)\par
\tab\tab\tab subtract the test value (3C normally)\par
\tab\tab\tab branch indirect to n2 if not positive\par
\tab\tab\tab load top of stack (n3) and call deposit\par
\tab\tab\tab bump n3 and save in stack\par
\tab\tab\tab\par
\par
\'a2 FILL 28 START CHARACTER REP STOP\tab   (n1 n2 n3 -- )  var: (0000, 7002, 0028, 0020 (index), C0FD, D0FD, \par
   8100 M LT LOC TP CALL RETURN\tab\tab\tab\tab   (loop) 4580, FFFE, C1FD, 7001, 0001, 80FE, D1FD, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab   C2FE, D002, C100, 7001, 003C, 90FE, 4C98, fill, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab   C200, 4400, deposit, 7001, 0001, C0FE, 8200, D200, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab   74FF, index, 70E6, 7001, 8100, C0FE, 4400, typ,\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab   4C80, return)\par
\tab\tab\tab n1 is test value\par
\tab\tab\tab\par
\tab\tab\tab set up loop count to initial value of 0028 (40 decimal) and loop till it reaches zero\par
\tab\tab\tab branch to workarea (IX1) - 2, the accept routine. Load character pointer at IX1 -3\par
\tab\tab\tab bump address by 1 and store in IX1-3. load n1 and store as test value\par
\tab\tab\tab pick up the current character value, subtract test value, and return if not positive\par
\tab\tab\tab get n3, call deposit, bump up n3 by 1, decrement the index and loop unless zero\par
\tab\tab\tab if zero, load 8100 (CR), call typ, and return\par
\tab\tab\tab This loops to fill the input area with 40 characters \par
\par
\'a2 BLANK 0 M ST 1 TOD FF CS LX X3 GOR LT\tab (n -- n)  var: (0000, C200, 1881, 72FF, 7001, 6300, E8FE, \par
   0 TR 0 M ST 1 TOD 1 SUB LT 5 TR 224 M LT 0 MARK\tab     D000, 6314, 1881, 7001, 0001, 90FE, D005, \par
     0 TA LOOP RETURN\tab\tab\tab\tab\tab\tab     7001, 2424, C0FE, 6300, D700, 3189, 73FF, \par
\tab\tab\tab\tab\tab\tab\tab\tab\tab     70FC, 4C80, return)\par
\tab\tab\tab load top of stack (n), shift acc+ext right 1, drop, OR with 6300, store as value \par
\tab\tab\tab to load in IX3. Load IX3 with that value. divide by 2 and subtract 1. use this as \par
\tab\tab\tab word (cell) address for storing characters. load two blanks, load IX3 with 0, \par
\tab\tab\tab store into the calculated address, decrement IX3, skip the loop and return\par
\par
\'a2 LIZ ALPHA WTC M LT 1 TS 2 TS\tab\tab ( -- )  var: ()\par
   28 M LT 3 TS 3 CS LOC BLANK CALL\par
   LOC FILL CALL 0 M ST FF SBU ST ALPHA TM FD CS RETURN\par
\par
\'a2 ' 3C M LT 1 TS 1 CS LOC LIZ CALL RETURN\tab\tab ( -- )  var: ()\par
\par
\'a2 ( 2F M LT 1 TS 1 CS LOC LIZ CALL RETURN\tab\tab ( -- )  var: ()\par
\par
:$ 'OK' REPLY;\tab\tab\tab\tab\tab ( -- )  gen: (creates string with OK and )\par
\par
:FILE 7 VECTOR; \tab\tab\tab\tab\tab\tab ( -- )  gen: ()\par
\par
FILE \tab\tab\tab\tab\tab\tab\tab\tab ( -- )  var: ()\par
\par
:LINE INTEGER;\tab\tab\tab\tab\tab\tab ( -- )  gen: ()\par
\par
\'a2 POSITION 0 M ST 4 TOD 1 CS 0 TS\tab\tab\tab\tab ( -- )  var: ()\par
     LOC SECTOR CALL 0 M ST F GAND LT 14 MUL LT XCH\par
     IN ADD LT 0 TS RETURN\par
\par
\'a2 FILL 28 START LOC ACCEPT CALL REP STOP RETURN\tab\tab ( -- )  var: ()\par
\par
:L LINE VALUE; \tab\tab\tab\tab\tab\tab ( -- )  gen: ()\par
   \par
:RELATIVE FILE 5+ VALUE+;\tab\tab\tab\tab ( -- )  gen: ()\par
\par
:T DUP LINE= RELATIVE POSITION WTC 28 MESSAGE;\tab ( -- )  gen: ()\par
\par
:EXAMINE SWAP IN WTC + SWAP MESSAGE;\tab\tab ( -- )  gen: ()\par
\par
:EMPLACE 3C IN WTC+ 28 FILL DROP DROP DROP WRITE;\tab ( -- )  gen: ()\par
\par
:S INTEGER; \tab\tab\tab\tab\tab\tab ( -- )  gen: ()\par
\par
:SV S VALUE;\tab\tab\tab\tab\tab\tab ( -- )  gen: ()\par
\par
:MOVE TRANSIENT MARK SWAP M AT SWAP TA LOOP EXECUTE;\tab ( -- )  gen: ()\par
\par
:COMPARE 2 TR MARK 0 M AT SWAP SUB AT EQUAL IF SWAP LOOP ELSE;\tab ( -- )  gen: ()\par
\par
\'a2 SEARCH IN 6- M LT S TM IN 1+ M MT 1 TR 0 START\tab ( -- )  var: ()\par
   S 7 MDM S M MT ALPHA 4 COMPARE SWAP STOP THEN 1 CS\par
   0 TS RETURN\par
\par
:CREATE 2E0 SECTOR IN 1+ DUP INC 1- 7*+ S= SV VALUE 1+ SV 5+=\tab ( -- )  gen: ()\par
    RAISE SV 6+= RAISE F+ SV 7+= SV ALPHA 4 MOVE WRITE;\tab\tab\tab\tab card 200\par
\par
:WARN 'NO SUCH FILE' REPLY;\tab\tab\tab\tab ( -- )  gen: ()\par
\par
:ACTIVATE 2E0 SECTOR SEARCH NONZERO WARN FIL SV 7 MOVE;\tab ( -- )  gen: ()\par
\par
:DELETE 2E0 SECTOR 0 SV 1+= WRITE;\tab\tab ( -- )  gen: ()\par
\par
:SEC INTEGER;\tab\tab\tab\tab\tab ( -- )  gen: ()\par
\par
OPERATON STRAIGHT FD X1 M RT IN 140+ WTC SUB LT EQUAL IF\tab ( -- )  var: ()\par
  SEC 1 MDM SEC M MT 1 CS 0 TS LOC SECTOR CALL\par
   IN WTC M LT FD X1 TR THEN\par
   FD X1 M RT LOC FETCH CALL RETURN\par
\par
\'a2 SET LOC STRAIGHT M LT FE X1 TR\tab\tab ( -- )  var: ()\par
   0 M ST FF CS FD X1 TR RETURN\par
\par
:INTERPRET TOP FILE 5+ VALUE 10/ 14* IN+ WTC\tab ( -- )  gen: ()\par
   SWAP DUP SEC= SECTOR SET;\par
\par
:RETRIEVE ACTIVATE INTERPRET;\tab\tab\tab ( -- )  gen: ()\par
\par
:XT SX INST 0 M LT;\tab\tab\tab\tab ( -- )  gen: ()\par
\par
\'a2 FORGET 1 X3 XT E TM 4 SUB LT E1 TM 3 X3 M RT\tab\tab ( -- )  var: ()\par
  IC TM RETURN\par
\par
\'a2 REMEMBER LOC ENTRY CALL\tab\tab\tab ( -- )  var: ()\par
   LOC FORGET M LT 2 X3 TR IC M MT 3 X3 TR RETURN\par
\par
LOC DONE 0A= HOME 'HI THERE' REPLY CONSOLE}